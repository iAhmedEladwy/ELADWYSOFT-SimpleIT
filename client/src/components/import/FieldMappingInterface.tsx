import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { CheckCircle, AlertTriangle, XCircle, Download, Upload } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';

interface FileColumn {
  name: string;
  sampleValues: string[];
  dataType: 'text' | 'number' | 'date' | 'unknown';
}

interface DatabaseField {
  name: string;
  displayName: string;
  description: string;
  dataType: 'text' | 'number' | 'date' | 'enum' | 'boolean';
  required: boolean;
  autoGenerated: boolean;
  enumValues?: string[];
  example?: string;
}

interface FieldMapping {
  sourceColumn: string | null;
  targetField: string;
  isValid: boolean;
  warnings: string[];
}

interface FieldMappingInterfaceProps {
  entityType: 'employees' | 'assets' | 'tickets';
  fileData: any[];
  fileColumns: FileColumn[];
  onMappingComplete: (mappings: FieldMapping[]) => void;
  onCancel: () => void;
}

export function FieldMappingInterface({
  entityType,
  fileData,
  fileColumns,
  onMappingComplete,
  onCancel
}: FieldMappingInterfaceProps) {
  const [databaseFields, setDatabaseFields] = useState<DatabaseField[]>([]);
  const [mappings, setMappings] = useState<FieldMapping[]>([]);
  const [validationSummary, setValidationSummary] = useState({
    requiredMapped: 0,
    totalRequired: 0,
    warnings: 0,
    validRecords: 0
  });
  const [savedTemplates, setSavedTemplates] = useState<string[]>([]);
  const [templateName, setTemplateName] = useState('');
  const { toast } = useToast();

  // Fetch database schema for the entity type
  useEffect(() => {
    const fetchSchema = async () => {
      try {
        const response = await fetch(`/api/import/schema/${entityType}`, {
          credentials: 'include'
        });
        const schema = await response.json();
        setDatabaseFields(schema.fields || []);
        
        // Initialize mappings
        const initialMappings = (schema.fields || []).map((field: DatabaseField) => ({
          sourceColumn: suggestMapping(field, fileColumns),
          targetField: field.name,
          isValid: false,
          warnings: []
        }));
        setMappings(initialMappings);
      } catch (error) {
        console.error('Failed to fetch schema:', error);
      }
    };

    fetchSchema();
  }, [entityType, fileColumns]);

  // Smart mapping suggestions based on field names
  const suggestMapping = (field: DatabaseField, columns: FileColumn[]): string | null => {
    const fieldName = field.name.toLowerCase();
    const displayName = field.displayName.toLowerCase();
    
    // Direct name matches
    for (const col of columns) {
      const colName = col.name.toLowerCase();
      if (colName === fieldName || colName === displayName) {
        return col.name;
      }
    }
    
    // Partial matches for common field patterns
    const patterns = {
      'englishname': ['name', 'english name', 'english name*', 'full name', 'employee name'],
      'arabicname': ['arabic name', 'arabic', 'name arabic'],
      'email': ['email', 'email address', 'corporate email', 'personal email'],
      'department': ['department', 'department*', 'dept', 'division'],
      'idnumber': ['id number', 'id number*', 'national id', 'employee id'],
      'title': ['title', 'title*', 'position', 'job title'],
      'directmanager': ['direct manager', 'direct manager id', 'manager', 'manager id'],
      'employmenttype': ['employment type', 'type', 'employment', 'contract type'],
      'joiningdate': ['joining date', 'joining date*', 'start date', 'hire date', 'date joined'],
      'personalmobile': ['personal mobile', 'mobile', 'phone', 'personal phone'],
      'personalemail': ['personal email', 'email', 'personal mail'],
      'assetid': ['asset id', 'asset number', 'id'],
      'type': ['type', 'type*', 'asset type', 'category'],
      'brand': ['brand', 'brand*', 'manufacturer', 'make'],
      'modelnumber': ['model number', 'model no', 'model'],
      'modelname': ['model name', 'name', 'product name'],
      'serialnumber': ['serial number', 'serial number*', 'serial', 'sn'],
      // ✅ FIXED - Separate patterns for each field:
      'specs': ['specifications', 'specs', 'description'],  // Removed cpu, ram, storage
      'cpu': ['cpu', 'processor', 'chip'],                  // ✅ NEW - CPU specific
      'ram': ['ram', 'memory', 'ram memory'],               // ✅ NEW - RAM specific  
      'storage': ['storage', 'disk', 'drive', 'ssd', 'hdd'], // ✅ NEW - Storage specific
      'status': ['status', 'condition', 'state'],
      'purchasedate': ['purchase date', 'buy date', 'date purchased'],
      'buyprice': ['buy price', 'price', 'cost', 'purchase price'],
      'warrantyexpirydate': ['warranty expiry date', 'warranty date', 'warranty end'],
      'lifespan': ['life span', 'lifespan', 'expected life'],
      'outofboxos': ['out of box os', 'os', 'operating system'],
      'assignedemployeeid': ['assigned employee id', 'assigned to', 'employee'],
      'ticketid': ['ticket id', 'ticket number', 'id'],
      'summary': ['summary', 'title', 'subject', 'description'],
      'priority': ['priority', 'urgency', 'importance']
    };
    
    const suggestions = patterns[fieldName as keyof typeof patterns];
    if (suggestions) {
      for (const col of columns) {
        const colName = col.name.toLowerCase();
        if (suggestions.some(suggestion => colName.includes(suggestion))) {
          return col.name;
        }
      }
    }
    
    return null;
  };

  // Update mapping for a specific field
  const updateMapping = (targetField: string, sourceColumn: string | null) => {
    setMappings(prev => prev.map(mapping => 
      mapping.targetField === targetField 
        ? { ...mapping, sourceColumn, isValid: validateMapping(targetField, sourceColumn), warnings: getValidationWarnings(targetField, sourceColumn) }
        : mapping
    ));
  };

  // Validate individual mapping
  const validateMapping = (targetField: string, sourceColumn: string | null): boolean => {
    const field = databaseFields.find(f => f.name === targetField);
    if (!field) return false;
    
    if (field.required && !sourceColumn) return false;
    if (field.autoGenerated && sourceColumn) return false;
    
    return true;
  };

  // Get validation warnings for a mapping
  const getValidationWarnings = (targetField: string, sourceColumn: string | null): string[] => {
    const warnings: string[] = [];
    const field = databaseFields.find(f => f.name === targetField);
    const column = fileColumns.find(c => c.name === sourceColumn);
    
    if (!field || !column) return warnings;
    
    // Data type compatibility warnings
    if (field.dataType === 'date' && column.dataType !== 'date') {
      warnings.push('Date format may need conversion');
    }
    
    if (field.dataType === 'number' && column.dataType !== 'number') {
      warnings.push('Numeric conversion required');
    }
    
    // Enum value validation
    if (field.dataType === 'enum' && field.enumValues) {
      const hasInvalidValues = column.sampleValues.some(value => 
        value && value.trim() !== '' && !field.enumValues!.includes(value)
      );
      if (hasInvalidValues) {
        warnings.push(`Contains values not in: ${field.enumValues.join(', ')}`);
      }
    }
    
    return warnings;
  };

  // Calculate validation summary
  useEffect(() => {
    const requiredFields = databaseFields.filter(f => f.required && !f.autoGenerated);
    const mappedRequired = mappings.filter(m => {
      const field = databaseFields.find(f => f.name === m.targetField);
      return field?.required && !field?.autoGenerated && m.sourceColumn;
    });
    
    const totalWarnings = mappings.reduce((sum, m) => sum + m.warnings.length, 0);
    const validRecords = fileData.filter(row => {
      return mappings.every(mapping => {
        const field = databaseFields.find(f => f.name === mapping.targetField);
        if (!field?.required || field?.autoGenerated) return true;
        return mapping.sourceColumn && row[mapping.sourceColumn];
      });
    }).length;
    
    setValidationSummary({
      requiredMapped: mappedRequired.length,
      totalRequired: requiredFields.length,
      warnings: totalWarnings,
      validRecords
    });
  }, [mappings, databaseFields, fileData]);

  // Save mapping template
  const saveTemplate = () => {
    if (!templateName.trim()) {
      toast({
        title: 'Template Name Required',
        description: 'Please enter a name for this mapping template.',
        variant: 'destructive'
      });
      return;
    }
    
    const template = {
      name: templateName,
      entityType,
      mappings: mappings.filter(m => m.sourceColumn)
    };
    
    localStorage.setItem(`mapping-template-${templateName}`, JSON.stringify(template));
    setSavedTemplates(prev => [...prev.filter(t => t !== templateName), templateName]);
    setTemplateName('');
    
    toast({
      title: 'Template Saved',
      description: `Mapping template "${templateName}" has been saved.`
    });
  };

  // Load mapping template
  const loadTemplate = (templateName: string) => {
    try {
      const template = localStorage.getItem(`mapping-template-${templateName}`);
      if (template) {
        const parsed = JSON.parse(template);
        if (parsed.entityType === entityType) {
          setMappings(prev => prev.map(mapping => {
            const savedMapping = parsed.mappings.find((m: any) => m.targetField === mapping.targetField);
            return savedMapping || mapping;
          }));
          
          toast({
            title: 'Template Loaded',
            description: `Mapping template "${templateName}" has been applied.`
          });
        }
      }
    } catch (error) {
      console.error('Failed to load template:', error);
    }
  };

  // Check if import can proceed
  const canProceedWithImport = validationSummary.requiredMapped === validationSummary.totalRequired;

  return (
    <div className="space-y-6">
      {/* File Preview */}
      <Card>
        <CardHeader>
          <CardTitle>File Preview</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="mb-4">
            <p className="text-sm text-gray-600">
              {fileData.length} rows detected • {fileColumns.length} columns found
            </p>
          </div>
          
          <div className="overflow-x-auto">
            <table className="w-full border-collapse border border-gray-300">
              <thead>
                <tr className="bg-gray-50">
                  {fileColumns.map(col => (
                    <th key={col.name} className="border border-gray-300 px-3 py-2 text-left text-sm font-medium">
                      {col.name}
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {fileData.slice(0, 3).map((row, idx) => (
                  <tr key={idx}>
                    {fileColumns.map(col => (
                      <td key={col.name} className="border border-gray-300 px-3 py-2 text-sm">
                        {row[col.name] || ''}
                      </td>
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </CardContent>
      </Card>

      {/* Field Mapping Interface */}
      <Card>
        <CardHeader>
          <CardTitle>Field Mapping</CardTitle>
          <p className="text-sm text-gray-600">
            Map your file columns to database fields. Required fields are marked with *.
          </p>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Database Fields */}
            <div>
              <h3 className="font-semibold mb-4">Database Fields</h3>
              <div className="space-y-3">
                {databaseFields.map(field => {
                  const mapping = mappings.find(m => m.targetField === field.name);
                  const isRequired = field.required && !field.autoGenerated;
                  const isMapped = mapping?.sourceColumn;
                  
                  return (
                    <div key={field.name} className="p-3 border rounded-lg">
                      <div className="flex items-center gap-2 mb-2">
                        <span className="font-medium">
                          {field.displayName}
                          {isRequired && <span className="text-red-500 ml-1">*</span>}
                        </span>
                        {field.autoGenerated && (
                          <Badge variant="secondary" className="text-xs">System Generated</Badge>
                        )}
                        {isMapped && <CheckCircle className="h-4 w-4 text-green-500" />}
                      </div>
                      
                      <p className="text-xs text-gray-600 mb-2">{field.description}</p>
                      
                      {field.enumValues && (
                        <p className="text-xs text-blue-600 mb-2">
                          Valid values: {field.enumValues.join(', ')}
                        </p>
                      )}
                      
                      {!field.autoGenerated && (
                        <Select
                          value={mapping?.sourceColumn || 'none'}
                          onValueChange={(value) => updateMapping(field.name, value === 'none' ? null : value)}
                        >
                          <SelectTrigger className="h-8">
                            <SelectValue placeholder="Select column..." />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="none">No mapping</SelectItem>
                            {fileColumns.map(col => (
                              <SelectItem key={col.name} value={col.name}>
                                {col.name}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      )}
                      
                      {mapping?.warnings && mapping.warnings.length > 0 && (
                        <div className="mt-2">
                          {mapping.warnings.map((warning, idx) => (
                            <p key={idx} className="text-xs text-amber-600 flex items-center gap-1">
                              <AlertTriangle className="h-3 w-3" />
                              {warning}
                            </p>
                          ))}
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>

            {/* Source Columns */}
            <div>
              <h3 className="font-semibold mb-4">Your File Columns</h3>
              <div className="space-y-3">
                {fileColumns.map(column => {
                  const isMapped = mappings.some(m => m.sourceColumn === column.name);
                  
                  return (
                    <div key={column.name} className="p-3 border rounded-lg">
                      <div className="flex items-center gap-2 mb-2">
                        <span className="font-medium">{column.name}</span>
                        <Badge variant="outline" className="text-xs">
                          {column.dataType}
                        </Badge>
                        {isMapped && <CheckCircle className="h-4 w-4 text-green-500" />}
                      </div>
                      
                      <div className="text-xs text-gray-600">
                        <p className="mb-1">Sample values:</p>
                        <p className="italic">
                          {column.sampleValues.slice(0, 3).join(', ')}
                          {column.sampleValues.length > 3 && '...'}
                        </p>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Validation Summary */}
      <Card>
        <CardHeader>
          <CardTitle>Validation Summary</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
            <div className="flex items-center gap-2">
              {canProceedWithImport ? (
                <CheckCircle className="h-5 w-5 text-green-500" />
              ) : (
                <XCircle className="h-5 w-5 text-red-500" />
              )}
              <span className="text-sm">
                Required fields: {validationSummary.requiredMapped}/{validationSummary.totalRequired}
              </span>
            </div>
            
            <div className="flex items-center gap-2">
              <AlertTriangle className="h-5 w-5 text-amber-500" />
              <span className="text-sm">
                Warnings: {validationSummary.warnings}
              </span>
            </div>
            
            <div className="flex items-center gap-2">
              <CheckCircle className="h-5 w-5 text-blue-500" />
              <span className="text-sm">
                Valid records: {validationSummary.validRecords}/{fileData.length}
              </span>
            </div>
          </div>
          
          {!canProceedWithImport && (
            <Alert>
              <AlertTriangle className="h-4 w-4" />
              <AlertDescription>
                Please map all required fields before proceeding with the import.
              </AlertDescription>
            </Alert>
          )}
        </CardContent>
      </Card>

      {/* Template Management */}
      <Card>
        <CardHeader>
          <CardTitle>Mapping Templates</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex gap-2 mb-4">
            <input
              type="text"
              placeholder="Template name"
              value={templateName}
              onChange={(e) => setTemplateName(e.target.value)}
              className="flex-1 px-3 py-2 border rounded"
            />
            <Button onClick={saveTemplate} variant="outline" size="sm">
              <Download className="h-4 w-4 mr-2" />
              Save Template
            </Button>
          </div>
          
          {savedTemplates.length > 0 && (
            <div className="space-y-2">
              <p className="text-sm font-medium">Saved Templates:</p>
              {savedTemplates.map(template => (
                <div key={template} className="flex items-center justify-between p-2 border rounded">
                  <span className="text-sm">{template}</span>
                  <Button onClick={() => loadTemplate(template)} variant="ghost" size="sm">
                    <Upload className="h-4 w-4 mr-2" />
                    Load
                  </Button>
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Action Buttons */}
      <div className="flex justify-between">
        <Button onClick={onCancel} variant="outline">
          Cancel
        </Button>
        
        <div className="space-x-2">
          <Button 
            onClick={() => onMappingComplete(mappings.filter(m => m.sourceColumn))}
            disabled={!canProceedWithImport}
            variant="default"
          >
            Import All Records
          </Button>
          
          {validationSummary.validRecords < fileData.length && (
            <Button 
              onClick={() => onMappingComplete(mappings.filter(m => m.sourceColumn))}
              variant="secondary"
            >
              Import Valid Records Only ({validationSummary.validRecords})
            </Button>
          )}
        </div>
      </div>
    </div>
  );
}